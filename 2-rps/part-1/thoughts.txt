So my immediate first thought is two things:

1. Let's make a dictionary that represents all the different player choices and their score value (a = 1, b = 2, c = 3, x = 1, y = 2, z = 3)
    - `values = { "A": 1, "Y": 1, "B": 2, "X": 2, "C": 3, "Z": 3 }`
2. Let's make a function to determine what your score is for a given round where your opponent plays move `a` and you play move `b`.
    - if you tie, the function returns `3 + <your-move-score>`
    - if you lose, the function returns `<your-move-score>`
    - if you win, the function returns `6 + <your-move-score>`

The logic for this is straightforward enough, if you're okay with nesting `if` statements. As this is a programming challenge and not my job, I'm OK with it. Maybe it'll need revisiting in part 2, but we're not gonna overengineer today.

    if(a == b):
        return 3 + b

    if(a == 1):
        #no need to check for tie condition cuz it's handled above
        if(b == 2):
            return 8
        else:
            return 3
    elif(a == 2):
        if(b == 1):
            return 1
        else:
            return 9
    elif(a == 3):
        if(b == 1):
            return 7
        else:
            return 2

wow, is that code bad. But nothing better immediately jumps to mind; it's 1:01 AM.

I stick this into a loop that processes a whole file, and voila:

    file = open("input.txt", 'r')

    line = file.readline()
    score = 0

    while(line != ""):
        # split takes a string and splits it up into a list based on the `delimiter` given (here, a space.)
        actions = line.split(" ")
        a = values[actions[0]]
        b = values[actions[1]]
        score = score + processScore(a,b)
        line = file.readline()

    file.close()
    print(score)

I get an error running because `split` doesn't get rid of the newlines. so instead, I need the lines to be something more like:
    
    a = values[actions[0].strip()]
    b = values[actions[1].strip()]

I run it against the test data, and it matches with a score of 15. Run it against the *real* data, and it turns out i'm WRONG!

So, where's the problem?

I look back at the data and realize I've flip-flopped the scores. You can even see it in the bullet point where I lay down the dictionary at the start of the blog.

I set the correct values, run again, and this time I've got the right number!