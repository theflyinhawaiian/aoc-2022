So the fundamental bits about this haven't changed much. Instead of splitting the strings in half, we're now parsing lines in groups of three.

My approach is pretty much the same; make a list for each string, and iterate through each string.

For each character, check to see if it's in the other packs. If it is, we found our character.

However, the setup for this is a little more annoying, considering we need to take multiple inputs from the data:

    text = " "
    sum = 0

    while text != "":
        elves = []
        for i in range(3):
            text = file.readline().strip()
            if text == "":
                print(sum)
                exit()
            elves.append(text)
        
        elves.sort(key = lambda x: len(x))
        
        commonChar = parseRucksacks(elves)

        sum = sum + getValue(commonChar)

For parseRucksacks, we have some truly ugly stuff. 

    idx = 0
    contents = [[], [], []]

    # we've sorted the strings, so packs[2] is the longest string
    while idx < len(packs[2]):
        packIdx = 0
        # go through each pack and index `packIdx`
        while packIdx < len(packs):
            # If we've hit the end of the string, skip
            if(len(packs[packIdx]) <= idx):
                packIdx = packIdx + 1
                continue

            matchCount = 0
            char = packs[packIdx][idx]

            # check to see if the current char has been found yet
            dictIdx = 0
            while dictIdx < len(contents):
                if char in contents[dictIdx] and dictIdx != packIdx:
                    matchCount = matchCount + 1
                dictIdx = dictIdx + 1
            
            # if its matchCount is 2, it's present in both other packs. Return it!
            if matchCount == 2:
                return char
            else:
                contents[packIdx].append(char)

            
            packIdx = packIdx + 1
        idx = idx + 1